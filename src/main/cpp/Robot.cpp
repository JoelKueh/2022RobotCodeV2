/******************************************************************************************
 * 
 * FOR THOSE WHO ARE TRYING TO READ THROUGH THE CODE TO GET A BETTER UNDERSTANDING
 * OF HOW THINGS WORK
 * 
 * This is the code that was used in last years robot (2022 InfiniteRecharge).
 * 
 * The important code is all contained in the /cpp and /include folders. Almost everything else is
 * autogenerated, you don't need to worry about it. 
 * 
 * Each .cpp and .h file will have comments like this describing the purpose of different lines of code.
 * Certain .cpp and .h files will contain further in-depth explanations of things like classes,
 * but I would ultimately recommend that to understand things on that level, you both consult the internet
 * and/or ask me (over text in the robotics group chat, or by email kuehn348@umn.edu).
 * 
 * Oh, and anything you see in the /* or // blocks is a comment. It is just something that I've added to help
 * explain what you're reading.
 * 
 * With that said, enjoy reading through my code
 * 
******************************************************************************************/


/**************************************************************************************
 * The first section of every .cpp and .h file is the include section.
 * 
 * #include searches for another file, and attaches it to the file that it was run from.
 * I like to think of it replacing itself with the contents of the file.
 * 
 * #include "Robot.h" is replaced by the contents of Robot.h
**************************************************************************************/

#include "Robot.h"

#include <fmt/core.h>
#include <cmath>

#include <wpinet/PortForwarder.h>
#include <frc/smartdashboard/SmartDashboard.h>
#include <frc/Timer.h>

/*******************************************************************************
 * This section right here is the actual meat of the robot code.
 * 
 * RobotInit, RobotPeriodic, AutonomousInit, etc... are all what we call "entrypoints"
 * into the program. Code outside of these functions can be thought of as setup, code that
 * runs in these functions is actually executed.
********************************************************************************/

/// @brief Runs once upon the robot powering on.
/// This is a great place to put different pieces of initialization code.
void Robot::RobotInit()
{
  // This has to do with classes and class systems. If you have forgotten this part, I would recomend that you either call or email me
  // and I'll try to explain.
  m_Timer = new frc::Timer();
  m_Xbox = new frc::XboxController(WiringDiagram::c_Xbox);
  m_Gyro = new frc::ADXRS450_Gyro(frc::SPI::Port::kOnboardCS0);
  m_AutoSwitch = new frc::DigitalInput(WiringDiagram::c_AutoSwitch);
  m_Turret = new Turret();
  m_Intake = new Intake();
  m_Hanger = new Hanger();
  m_Drive = new Drive();
  m_Limelight = new Limelight();

  // Here's a great example of initialization code. I initialize the Timer used for the autonomous section,
  // I calibrate the gyroscope, and I turn on the LED for the Limelight camera.
  m_Timer->Start();
  m_Gyro->Calibrate();
  m_Limelight->LEDOn();
}

/// @brief Called Every 20 ms, no matter what mode you are in. It even runs when disabled.
/// I haven't really had to use it, but I could see a world where you might need to, for diagnostics or something.
void Robot::RobotPeriodic() {}

/// @brief Called once, right at the beginning of the Autonomous segment.
/// Good for initializing things.
void Robot::AutonomousInit()
{
  // See, more calibration and initilization code.
  resetDone = false;
  m_Gyro->Reset();
  m_Timer->Reset();
  m_Hanger->In();
  m_Intake->Out();

  m_AutoSwitchState = !m_AutoSwitch->Get();
  autoState = 0;
}

/// @brief Called repeatedly during Autonomous.
/// This is where I make everything drive.
void Robot::AutonomousPeriodic()
{
  // I don't think this is the right way to do this.
  // It works well, but it isn't very safe. I bypassed the safety mechanism where the robot stops moving if we are stuck
  // in an infinite loop. DON'T DO THIS. I will refactor mecnaum drive later.
  m_Drive->UpdateMecanumDrive();

  // Waits for the reset to finish before starting the autonomous section.
  if (!resetDone)
  {
    if(m_Intake->Init(0_s, m_Timer->Get()) && m_Turret->ZeroElevator()) { resetDone = true; m_Timer->Reset(); }
  }
  else
  {
    // Once the reset is done, it checks to see whether the switch is up or down, and runs the corresponding autonomous function
    if(m_AutoSwitchState)
    {
      ThreeBallAuto();
    }
    else
    {
      TwoBallAuto();
    }
  }
}

/// @brief Runs once at the beginning of the teleoperated portion.
void Robot::TeleopInit()
{
  // I run some calibration code once again to make sure everything is still good. (There are 2 or 3 seconds of downtime for this to happen as well).
  StopTargeting();
  resetDone = false;
  m_Timer->Reset();
  m_Hanger->In();
  m_Intake->Out();
}

/// @brief Runs repeatedly throught the beginning of the teleoperated portion.
/// This is where most of your code will be run as the majority of your time is spent here.
void Robot::TeleopPeriodic()
{
  if(!resetDone)
  {
    if(m_Intake->Init(0_s, m_Timer->Get()) && m_Turret->ZeroElevator()) { resetDone = true; }
  }
  else
  {
    m_Drive->UpdateMecanumDrive();

    double xboxRB = m_Xbox->GetRightBumperPressed();
    if(m_Xbox->GetLeftBumper() && xboxRB)
    {
      hangerOut = !hangerOut;
      m_Hanger->Toggle();
    }

    if(m_Xbox->GetPOV() == 0 && xboxRB)
    {
      intakeOut = !intakeOut;
      m_Intake->Toggle();
    }

    if(m_Xbox->GetPOV() == 90 && m_Xbox->GetBButtonPressed())
    {
      aimOverridden = true;
    }
    else if(m_Xbox->GetPOV() == 180 && m_Xbox->GetAButtonPressed())
    {
      aimOverridden = false;
    }
    frc::SmartDashboard::PutBoolean("Aim Overridden", aimOverridden);

    if(m_Xbox->GetYButtonPressed())
    {
      targeting = !targeting;
    }
    frc::SmartDashboard::PutBoolean("Targeting?", targeting);

    if(targeting && m_Limelight->TargetFound())
    {
      if(!aimOverridden)
      {
        AimedControl();
      }
      else
      {
        AimOverriddenControl();
      }
    }
    else
    {
      StopTargeting();

      m_Drive->MecanumDrive(m_Xbox->GetLeftY(), -m_Xbox->GetLeftX(), -m_Xbox->GetRightX());

      if(m_Xbox->GetRightTriggerAxis() > .15)
      {
        m_Intake->SpinForward();
        m_Turret->SetIndex(-.15);
      }
      else if(m_Xbox->GetLeftTriggerAxis() > .15)
      {
        m_Intake->SpinReverse();
      }
      else
      {
        m_Intake->Stop();
        m_Turret->SetIndex(0);
      }

      frc::SmartDashboard::PutBoolean("Locked On", lockedOn);
    }
  }
}

// This set runs when the robot is disabled and only when it is disabled. (Haven't found a use for it yet).
void Robot::DisabledInit() {}
void Robot::DisabledPeriodic() {}

// This runs when the robot is in test mode. I didn't ever use test, but it could be a very powerful tool if someone wanted
// to learn what it was.
void Robot::TestInit() {}
void Robot::TestPeriodic() {}

// I would assume this has to do with the robot simulation stuff. Once again, I never played around with it. It looks like it requires
// Precise measurement devices on the physical robot (such as encoders on all four wheels).
void Robot::SimulationInit() {}
void Robot::SimulationPeriodic() {}

/****************************************************************************************
 * This marks the end of the "entrypoint" functions and marks the beginning of the functions
 * that I wrote to be run elsewhere.
 * 
 * Code that is inside these functions is only run if it is called from another function.
*******************************************************************************************/

/// @brief A simple function which allows the human to control the turret if the limelight is malfunctioning.
void Robot::AimOverriddenControl()
{
  // This handly little tool is called SmartDashboard.
  // It is the best way to report robot data back to the driver.
  // You can also use #include <iostream>
  // and std::cout << "Text" << std::endl; for debugging
  // But nothing beats SmartDashboard for sending information in
  // the middle of a match.
  frc::SmartDashboard::PutBoolean("Locked On", lockedOn);

  // The POV is another name for the Xbox's D-Pad.
  // It returns values as a number of degrees from the top of the controller, so 0 is up and 270 is left.
  // This way, the driver can use the D-Pad to set target RPM's and Elevator angles for different shots.
  if(m_Xbox->GetPOV() == 0)
  {
    overriddenRPM = 2500;
    overriddenElevator = 10;
  }
  else if(m_Xbox->GetPOV() == 270)
  {
    overriddenRPM = 4000;
    overriddenElevator = 30;
  }

  // Here, I tell the Elevator and the FlyWheel to go to their setpoints that we chose above.
  // If the are within range, the function on the right returns true, which then sets the bool on the left to true.
  bool inElevatorRange = m_Turret->RunElevator(overriddenElevator);
  bool inFlywheelRange = m_Turret->SpinFlywheel(overriddenRPM);

  // If in range, or override pressed: FIRE!
  if((inElevatorRange && inFlywheelRange) || m_Xbox->GetXButtonPressed())
  {
    m_Turret->SetIndex(1);
    m_Intake->SpinForward();
  }
}

/// @brief This function handles the auto-aim for the robot.
/// @return It returns true if a shot was fired (this is used in autonomous to know when to move on).
bool Robot::AimedControl()
{
  // SmartDashboard again: awesome
  frc::SmartDashboard::PutBoolean("Locked On", lockedOn);

  // Stores a couple of values which will allow the Limelight to control the rotation of the robot in mecanum drive.
  double xOffset = m_Limelight->GetX();
  double strafePower = -m_Xbox->GetLeftX();
  double drivePower = m_Xbox->GetLeftY();

  // These are a couple of functions from the turret class that I use to get setpoints for the speed and angle of the turret
  // from the values that are read from the limelight. I found them by plotting points on desmos and then fitting a curve to the plot.
  double elevatorSetpoint = m_Turret->AngleToEleCounts(m_Limelight->GetY());
  double flywheelRPM = m_Turret->AngleToRPM(m_Limelight->GetY());

  // Like the funcitons above, these functions attempt to aim the robot at the target
  // MecanumDrivePID is particularly interesting because it lets the xbox controller handle strafing while the
  // limelight controlls the angle of the robot.
  bool inAngleRange = m_Drive->MecanumDrivePID(xOffset, strafePower, drivePower);
  bool inEleRange = m_Turret->RunElevator(elevatorSetpoint);
  bool inFlywheelRange = m_Turret->SpinFlywheel(flywheelRPM);

  // This is a switch case, it is quite nice. It allows me to switch between different parts of my shot routine.
  switch (aimingState)
  {
    // Case 0 just checks if everything is in range, then it attempts to shoot (once again, X is used as an override button)
    case 0:
    {
      if((inAngleRange && inEleRange && inFlywheelRange &&
        strafePower < .1 && strafePower > -.1 && drivePower < .1 && strafePower > -.1) ||
        m_Xbox->GetXButtonPressed())
      {
        lockedOn = true;
        aimingState++;

        m_Turret->SetIndex(1);
        m_Intake->SpinForward();
        
        lastShotTime = m_Timer->Get();
      }
      break;
    }
    // Here I do something interesting, we noticed a problem where the second ball would exit at a lower speed than the first ball.
    // This is an attempt to fix that. If you are curious about how it works. Ask me personally
    case 1:
    {
      if(m_Turret->FlywheelKickSeen())
      {
        lastKickTime = m_Timer->Get();
        m_Turret->SetIndex(0);
        aimingState++;
      }
      break;
    }
    // Also part of the solution mentioned above.
    case 2:
    {
      if(m_Timer->Get() - lastKickTime > .65_s)
      {
        m_Turret->SetIndex(1);

        aimingState++;
      }
      break;
    }
    // I stop targeting .8 seconds after the first ball was shot off.
    case 3:
    {
      if(m_Timer->Get() - lastKickTime > .8_s)
      {
        StopTargeting();
        return true;
      }
      break;
    }
    default: break;
  }

  // More data sent to smart dashboard.
  frc::SmartDashboard::PutBoolean("In Flywheel Range", inFlywheelRange);
  frc::SmartDashboard::PutBoolean("In Drive Range", inAngleRange);
  frc::SmartDashboard::PutBoolean("In Elevator Range", inEleRange);
  
  return false;
}

/// @brief Code for the three ball autonomous.
void Robot::ThreeBallAuto()
{
  // This is all handled by a big switch case, with Timed sections which allow you to move on to the next stage.
  // With your new encoded drive motors, you should be able to implement this more accurately than I did.

  switch (autoState)
  {
    case 0:
    {
      // DRIVING NEGATIVE IS DRIVING FORWARDS
      m_Drive->MecanumDrive(-.5, 0, 0);
      m_Intake->SpinForward();
      m_Turret->SetIndex(-.15);

      m_Turret->SpinFlywheel(2750);
      m_Turret->RunElevator(5);

      if(m_Timer->Get() > .8_s) { autoState++; m_Drive->MecanumDrive(0, 0, 0); }
      break;
    }
    case 1:
    {
      m_Turret->SpinFlywheel(2750);
      m_Turret->RunElevator(5);

      if(m_Timer->Get() > 1.4_s) { autoState++; }
      break;
    }
    case 2:
    {
      m_Drive->MecanumDrive(1, 0, 0);

      m_Turret->SpinFlywheel(2750);
      m_Turret->RunElevator(5);

      if(m_Timer->Get() > 1.925_s) { autoState++; m_Drive->MecanumDrive(0, 0, 0); }
      break;
    }
    case 3:
    {
      double gyro = std::fmod(m_Gyro->GetAngle(), 360);
      // frc::SmartDashboard::PutNumber("Gyro", gyro);
      m_Drive->MecanumDrivePID(205 - gyro);

      bool inFlywheelRange = m_Turret->SpinFlywheel(2750);
      bool inDriveRange = m_Turret->RunElevator(5);

      if(m_Drive->AtSetpoint() && inFlywheelRange && inDriveRange)
      {
        lockedOn = true;
      }

      if(lockedOn)
      {
        if(ShootUnaimed())
        {
          autoState++;
        }
      }
      break;
    }
    case 4:
    {
      double gyro = std::fmod(m_Gyro->GetAngle(), 360);
      // frc::SmartDashboard::PutNumber("Gyro", gyro);
      m_Drive->MecanumDrivePID(90 - gyro);

      if(m_Drive->AtSetpoint()) { autoState++; autoSecondTurnTime = m_Timer->Get(); }
      break;
    }
    case 5:
    {
      m_Drive->MecanumDrive(-1, 0, 0);

      m_Turret->SpinFlywheel(3400);
      m_Turret->RunElevator(18);

      if(m_Timer->Get() > autoSecondTurnTime + 1.2_s) { autoState++; m_Drive->MecanumDrive(0, 0, 0); }
      break;
    }
    case 6:
    {
      m_Turret->SpinFlywheel(3400);
      m_Turret->RunElevator(18);

      if(m_Timer->Get() > autoSecondTurnTime + 1.8_s) { autoState++; lockedOn = false; }
      break;
    }
    case 7:
    {
      double gyro = std::fmod(m_Gyro->GetAngle(), 360);
      // frc::SmartDashboard::PutNumber("Gyro", gyro);
      m_Drive->MecanumDrivePID(245 - gyro);

      bool inFlywheelRange = m_Turret->SpinFlywheel(3400);
      bool inDriveRange = m_Turret->RunElevator(14);

      if(m_Drive->AtSetpoint() && inFlywheelRange && inDriveRange)
      {
        lockedOn = true;
      }

      if(lockedOn)
      {
        if(ShootUnaimed())
        {
          aimingState++;
        }
      }
      break;
    }
    default: break;
  }
}

/// @brief Code for the two ball autonomous.
void Robot::TwoBallAuto()
{
  switch (autoState)
  {
    case 0:
    {
      // DRIVING NEGATIVE IS DRIVING FORWARDS
      m_Drive->MecanumDrive(-.5, 0, 0);
      m_Intake->SpinForward();
      m_Turret->SetIndex(-.15);

      m_Turret->SpinFlywheel(2750);
      m_Turret->RunElevator(5);

      if(m_Timer->Get() > 1.4_s) { autoState++; m_Drive->MecanumDrive(0, 0, 0); }
      break;
    }
    case 1:
    {
      m_Turret->SpinFlywheel(2750);
      m_Turret->RunElevator(5);

      if(m_Timer->Get() > 1.5_s) { autoState++; }
      break;
    }
    case 2:
    {
      double gyro = std::fmod(m_Gyro->GetAngle(), 360);
      // frc::SmartDashboard::PutNumber("Gyro", gyro);
      m_Drive->MecanumDrivePID(180 - gyro);

      if(m_Drive->AtSetpoint()) { autoState++; }
      break;
    }
    case 3:
    {
      if(AimedControl())
      {
        autoState++;
      }
      break;
    }
  }
}

/// @brief A simple function which makes sure everything gets stopped properly at the end of the aiming routine.
void Robot::StopTargeting()
{
  m_Turret->SetIndex(0);
  m_Turret->StopElevator();
  m_Turret->StopFlywheel();
  aimingState = 0;
  targeting = false;
  lockedOn = false;
}

/// @brief Just shoots the ball. Used when Limelight is malfunctioning
/// @return Returns true .95 seconds after the first ball has been shot.
bool Robot::ShootUnaimed()
{
  switch (aimingState)
  {
    case 0:
    {
      lockedOn = true;
      aimingState++;

      m_Turret->SetIndex(1);
      m_Intake->SpinForward();
        
      lastShotTime = m_Timer->Get();
      break;
    }
    case 1:
    {
      if(m_Timer->Get() > lastShotTime + .15_s)
      {
        m_Turret->SetIndex(0);
        aimingState++;
      }
      break;
    }
    case 2:
    {
      if(m_Timer->Get() > lastKickTime + .8_s)
      {
        m_Turret->SetIndex(1);

        aimingState++;
      }
      break;
    }
    case 3:
    {
      if(m_Timer->Get() > lastKickTime + .95_s)
      {
        StopTargeting();
        return true;
      }
      break;
    }
    default: break;
  }
  return false;
}

#ifndef RUNNING_FRC_TESTS
int main() {
  return frc::StartRobot<Robot>();
}
#endif
